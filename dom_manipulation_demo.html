<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DOM Manipulation Demo</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f5f5f5;
      }

      .container {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
      }

      .section {
        margin-bottom: 30px;
        padding: 15px;
        border: 2px solid #e0e0e0;
        border-radius: 5px;
      }

      .section h2 {
        color: #333;
        border-bottom: 2px solid #4caf50;
        padding-bottom: 10px;
      }

      button {
        background-color: #4caf50;
        color: white;
        padding: 10px 15px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        margin: 5px;
        font-size: 14px;
      }

      button:hover {
        background-color: #45a049;
      }

      button.danger {
        background-color: #f44336;
      }

      button.danger:hover {
        background-color: #da190b;
      }

      button.info {
        background-color: #2196f3;
      }

      button.info:hover {
        background-color: #0b7dda;
      }

      .dynamic-content {
        min-height: 100px;
        border: 2px dashed #ccc;
        padding: 15px;
        margin: 10px 0;
        background-color: #fafafa;
      }

      .element-item {
        background-color: #e3f2fd;
        border: 1px solid #2196f3;
        padding: 10px;
        margin: 5px 0;
        border-radius: 3px;
        position: relative;
      }

      .element-item .remove-btn {
        position: absolute;
        top: 5px;
        right: 5px;
        background-color: #f44336;
        color: white;
        border: none;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        cursor: pointer;
        font-size: 12px;
      }

      .tree-structure {
        font-family: monospace;
        background-color: #f8f8f8;
        padding: 15px;
        border-radius: 5px;
        white-space: pre-line;
      }

      .highlighted {
        background-color: #ffeb3b !important;
        border: 2px solid #ff9800 !important;
      }

      .traversal-info {
        background-color: #e8f5e8;
        border: 1px solid #4caf50;
        padding: 10px;
        margin: 10px 0;
        border-radius: 5px;
      }

      input[type="text"] {
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        margin: 5px;
      }

      .family-tree {
        border: 1px solid #ddd;
        padding: 15px;
        margin: 10px 0;
        background-color: #f9f9f9;
      }

      .parent {
        border: 2px solid #4caf50;
        background-color: #e8f5e8;
        padding: 10px;
        margin: 5px 0;
      }

      .child {
        border: 2px solid #2196f3;
        background-color: #e3f2fd;
        padding: 8px;
        margin: 3px 0 3px 20px;
      }

      .grandchild {
        border: 2px solid #ff9800;
        background-color: #fff3e0;
        padding: 6px;
        margin: 2px 0 2px 40px;
      }

      .explanation {
        background-color: #f0f8ff;
        border-left: 4px solid #2196f3;
        padding: 15px;
        margin: 15px 0;
        border-radius: 5px;
      }

      .explanation h4 {
        color: #1976d2;
        margin-top: 15px;
      }

      .code-example {
        background-color: #f5f5f5;
        border: 1px solid #ddd;
        padding: 10px;
        margin: 10px 0;
        border-radius: 4px;
        font-family: "Courier New", monospace;
        font-size: 13px;
        overflow-x: auto;
      }

      .method-name {
        color: #d32f2f;
        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>DOM Manipulation Demonstration</h1>
      <p>
        This page demonstrates various DOM manipulation techniques including
        creating/removing elements, parent-child relationships, and DOM
        traversal.
      </p>

      <div class="explanation">
        <h3>What is DOM Manipulation?</h3>
        <p>
          The Document Object Model (DOM) is a programming interface for HTML
          documents. It represents the page structure as a tree of objects,
          allowing JavaScript to dynamically change the content, structure, and
          style of web pages.
        </p>

        <h4>Key Concepts:</h4>
        <ul>
          <li>
            <strong>Elements:</strong> HTML tags represented as objects in
            JavaScript
          </li>
          <li>
            <strong>Nodes:</strong> Every part of the document (elements, text,
            attributes)
          </li>
          <li>
            <strong>Parent-Child Relationships:</strong> How elements are nested
            within each other
          </li>
          <li>
            <strong>DOM Traversal:</strong> Methods to navigate and find
            elements in the DOM tree
          </li>
        </ul>
      </div>
    </div>

    <!-- Section A: Creating and Removing Elements -->
    <div class="container section" id="section-a">
      <h2>A. Creating and Removing Elements</h2>

      <div class="explanation">
        <h3>Element Creation Fundamentals</h3>
        <p>
          Creating elements dynamically allows you to build interactive web
          applications. JavaScript provides several methods to create and
          manipulate DOM elements.
        </p>

        <h4>Core Methods:</h4>
        <ul>
          <li>
            <span class="method-name">document.createElement()</span> - Creates
            a new HTML element
          </li>
          <li>
            <span class="method-name">appendChild()</span> - Adds a child
            element to a parent
          </li>
          <li>
            <span class="method-name">removeChild()</span> - Removes a child
            element from a parent
          </li>
          <li>
            <span class="method-name">remove()</span> - Removes the element
            directly (modern method)
          </li>
        </ul>
      </div>

      <div>
        <h3>Dynamic Element Creation</h3>
        <div class="explanation">
          <p>
            <strong>What this demonstrates:</strong> Basic element creation with
            user input, adding attributes, and programmatic removal.
          </p>
          <div class="code-example">
            // Create new element<br />
            const newElement = document.createElement('div');<br />
            newElement.className = 'element-item';<br />
            newElement.textContent = text;<br /><br />
            // Add to DOM<br />
            container.appendChild(newElement);
          </div>
          <p>
            <strong>Key Learning:</strong> Elements must be created first, then
            styled/configured, and finally added to the DOM to become visible.
          </p>
        </div>
        <input
          type="text"
          id="elementText"
          placeholder="Enter text for new element"
        />
        <button onclick="createElement()">Create Element</button>
        <button onclick="createElementWithAttributes()">
          Create Styled Element
        </button>
        <button onclick="clearAllElements()" class="danger">Clear All</button>
      </div>

      <div id="dynamicContainer" class="dynamic-content">
        <p><em>Dynamic elements will appear here...</em></p>
      </div>

      <div>
        <h3>Element Creation Methods</h3>
        <div class="explanation">
          <h4>Different Approaches to Creating Content:</h4>
          <ul>
            <li>
              <strong>innerHTML:</strong> Fast but can be vulnerable to XSS
              attacks if not careful with user input
            </li>
            <li>
              <strong>textContent:</strong> Safe for text-only content,
              automatically escapes HTML
            </li>
            <li>
              <strong>appendChild:</strong> Most secure and flexible, allows
              precise control over structure
            </li>
            <li>
              <strong>Complex Elements:</strong> Building sophisticated nested
              structures programmatically
            </li>
          </ul>
        </div>
        <button onclick="createWithInnerHTML()">Create with innerHTML</button>
        <button onclick="createWithTextContent()">
          Create with textContent
        </button>
        <button onclick="createWithAppendChild()">
          Create with appendChild
        </button>
        <button onclick="createComplexElement()">Create Complex Element</button>
      </div>
    </div>

    <!-- Section B: Parent-Child Relationships -->
    <div class="container section" id="section-b">
      <h2>B. Parent-Child Relationships</h2>

      <div class="explanation">
        <h3>Understanding DOM Hierarchy</h3>
        <p>
          The DOM represents HTML as a tree structure where elements can contain
          other elements (children), and each element has a parent (except the
          root). Understanding these relationships is crucial for effective DOM
          manipulation.
        </p>

        <h4>Key Relationship Properties:</h4>
        <ul>
          <li>
            <span class="method-name">parentElement</span> - Gets the parent of
            an element
          </li>
          <li>
            <span class="method-name">children</span> - Gets all child elements
          </li>
          <li>
            <span class="method-name"
              >firstElementChild / lastElementChild</span
            >
            - Gets first/last child
          </li>
          <li>
            <span class="method-name"
              >nextElementSibling / previousElementSibling</span
            >
            - Gets adjacent siblings
          </li>
        </ul>
      </div>

      <div>
        <h3>Family Tree Operations</h3>
        <div class="explanation">
          <p>
            <strong>What this demonstrates:</strong> Creating hierarchical
            structures and managing parent-child relationships dynamically.
          </p>
          <div class="code-example">
            // Create parent element<br />
            const parent = document.createElement('div');<br />
            parent.className = 'parent';<br /><br />
            // Create and add children<br />
            const child = document.createElement('div');<br />
            child.className = 'child';<br />
            parent.appendChild(child);
          </div>
          <p>
            <strong>Visual Hierarchy:</strong> Parent (green) → Children (blue)
            → Grandchildren (orange)
          </p>
        </div>
        <button onclick="createFamily()">Create Family Tree</button>
        <button onclick="addChild()">Add Child</button>
        <button onclick="addGrandchild()">Add Grandchild</button>
        <button onclick="removeLastChild()">Remove Last Child</button>
        <button onclick="showRelationships()" class="info">
          Show Relationships
        </button>
      </div>

      <div id="familyTree" class="family-tree">
        <p><em>Family tree will be created here...</em></p>
      </div>

      <div
        id="relationshipInfo"
        class="traversal-info"
        style="display: none"
      ></div>

      <div>
        <h3>Advanced Parent-Child Operations</h3>
        <div class="explanation">
          <h4>Precise Insertion and Manipulation:</h4>
          <ul>
            <li>
              <strong>insertBefore():</strong> Inserts an element before a
              specific child
            </li>
            <li>
              <strong>insertAfter():</strong> Custom implementation using
              insertBefore() and nextSibling
            </li>
            <li>
              <strong>replaceChild():</strong> Replaces one child with another
            </li>
            <li>
              <strong>cloneNode():</strong> Creates a copy of an element
              (shallow or deep)
            </li>
          </ul>
          <div class="code-example">
            // Insert before first child<br />
            parent.insertBefore(newElement, parent.firstElementChild);<br /><br />
            // Replace a child<br />
            parent.replaceChild(newChild, oldChild);<br /><br />
            // Clone with all descendants<br />
            const clone = element.cloneNode(true);
          </div>
        </div>
        <button onclick="insertBefore()">Insert Before</button>
        <button onclick="insertAfter()">Insert After</button>
        <button onclick="replaceChild()">Replace Child</button>
        <button onclick="cloneNode()">Clone Node</button>
      </div>
    </div>

    <!-- Section C: DOM Traversal -->
    <div class="container section" id="section-c">
      <h2>C. DOM Traversal</h2>

      <div class="explanation">
        <h3>Navigating the DOM Tree</h3>
        <p>
          DOM traversal involves moving through the document structure to find,
          access, or manipulate specific elements. This is essential for
          interactive web applications.
        </p>

        <h4>Traversal Categories:</h4>
        <ul>
          <li>
            <strong>Relational Navigation:</strong> Moving between parents,
            children, and siblings
          </li>
          <li>
            <strong>Query Methods:</strong> Finding elements by selectors, IDs,
            classes, or tags
          </li>
          <li>
            <strong>Tree Walking:</strong> Systematically visiting all nodes in
            the DOM
          </li>
        </ul>
      </div>

      <div>
        <h3>Navigation Methods</h3>
        <div class="explanation">
          <p>
            <strong>Interactive Demonstration:</strong> Click the buttons below
            to see how different traversal methods work. The highlighted
            elements show the results of each operation.
          </p>
          <div class="code-example">
            // Navigate to parent<br />
            element.parentElement;<br /><br />
            // Get all children<br />
            element.children;<br /><br />
            // Get siblings<br />
            element.nextElementSibling;<br />
            element.previousElementSibling;
          </div>
          <p>
            <strong>Tip:</strong> Click on any element in the demo area below to
            see its information!
          </p>
        </div>
        <button onclick="highlightParent()" class="info">
          Highlight Parent
        </button>
        <button onclick="highlightChildren()" class="info">
          Highlight Children
        </button>
        <button onclick="highlightSiblings()" class="info">
          Highlight Siblings
        </button>
        <button onclick="highlightFirstLast()" class="info">
          Highlight First/Last
        </button>
        <button onclick="clearHighlights()">Clear Highlights</button>
      </div>

      <div id="traversalContainer" class="dynamic-content">
        <div class="element-item" data-info="First Element">
          First Element
          <div class="element-item" data-info="First Child">
            First Child
            <div class="element-item" data-info="Grandchild">Grandchild</div>
          </div>
        </div>
        <div class="element-item" data-info="Second Element">
          Second Element
          <div class="element-item" data-info="Second Child">Second Child</div>
        </div>
        <div class="element-item" data-info="Third Element">Third Element</div>
      </div>

      <div>
        <h3>Query Methods</h3>
        <div class="explanation">
          <h4>Different Ways to Find Elements:</h4>
          <ul>
            <li>
              <strong>getElementById():</strong> Finds one element by its ID
              attribute
            </li>
            <li>
              <strong>getElementsByClassName():</strong> Finds all elements with
              a specific class (live collection)
            </li>
            <li>
              <strong>getElementsByTagName():</strong> Finds all elements of a
              specific tag type
            </li>
            <li>
              <strong>querySelector():</strong> Finds the first element matching
              a CSS selector
            </li>
            <li>
              <strong>querySelectorAll():</strong> Finds all elements matching a
              CSS selector (static list)
            </li>
          </ul>
          <div class="code-example">
            // Try these selectors:<br />
            '.element-item' // All elements with class<br />
            '#traversalContainer' // Element with specific ID<br />
            'div[data-info]' // Divs with data-info attribute<br />
            '.element-item:first-child' // First child elements
          </div>
        </div>
        <input
          type="text"
          id="selectorInput"
          placeholder="Enter CSS selector"
        />
        <button onclick="queryElements()" class="info">Query Elements</button>
        <button onclick="demonstrateQueryMethods()" class="info">
          Demo Query Methods
        </button>
      </div>

      <div id="queryResults" class="traversal-info" style="display: none"></div>

      <div>
        <h3>Advanced Traversal</h3>
        <div class="explanation">
          <h4>Sophisticated Navigation Techniques:</h4>
          <ul>
            <li>
              <strong>Walk DOM Tree:</strong> Recursively visit every element
              and show the structure
            </li>
            <li>
              <strong>Find by Attribute:</strong> Locate elements based on
              custom attributes
            </li>
            <li>
              <strong>Get Element Path:</strong> Generate the complete CSS path
              to an element
            </li>
          </ul>
          <div class="code-example">
            // Recursive tree walking<br />
            function walkNode(node, depth = 0) {<br />
            &nbsp;&nbsp;// Process current node<br />
            &nbsp;&nbsp;Array.from(node.children).forEach(child => {<br />
            &nbsp;&nbsp;&nbsp;&nbsp;walkNode(child, depth + 1);<br />
            &nbsp;&nbsp;});<br />
            }
          </div>
        </div>
        <button onclick="walkDOMTree()" class="info">Walk DOM Tree</button>
        <button onclick="findElementsByAttribute()" class="info">
          Find by Attribute
        </button>
        <button onclick="getElementPath()" class="info">
          Get Element Path
        </button>
      </div>

      <div
        id="traversalResults"
        class="tree-structure"
        style="display: none"
      ></div>
    </div>

    <!-- Best Practices and Summary -->
    <div class="container">
      <h2>DOM Manipulation Best Practices & Summary</h2>

      <div class="explanation">
        <h3>Key Takeaways</h3>

        <h4>1. Element Creation Strategies:</h4>
        <ul>
          <li>
            <strong>Use appendChild() for security:</strong> Most secure method,
            prevents XSS attacks
          </li>
          <li>
            <strong>innerHTML for static content:</strong> Fast for known, safe
            HTML content
          </li>
          <li>
            <strong>textContent for text:</strong> Always safe for
            user-generated text content
          </li>
          <li>
            <strong>Document fragments:</strong> Use for multiple elements to
            minimize reflows
          </li>
        </ul>

        <h4>2. Parent-Child Relationship Management:</h4>
        <ul>
          <li>
            <strong>Understand the hierarchy:</strong> Every element has one
            parent, zero or more children
          </li>
          <li>
            <strong>Use :scope selector:</strong> For direct children queries
            (e.g., ':scope > .child')
          </li>
          <li>
            <strong>Clone wisely:</strong> Use cloneNode(true) for deep cloning,
            cloneNode(false) for shallow
          </li>
          <li>
            <strong>Insert positioning:</strong> insertBefore() is the
            foundation for all insertion operations
          </li>
        </ul>

        <h4>3. DOM Traversal Efficiency:</h4>
        <ul>
          <li>
            <strong>Cache DOM queries:</strong> Store frequently accessed
            elements in variables
          </li>
          <li>
            <strong>Use specific selectors:</strong> ID > class > tag for
            performance
          </li>
          <li>
            <strong>Prefer querySelectorAll:</strong> More flexible than
            getElementsByClassName
          </li>
          <li>
            <strong>Understand live vs static:</strong> getElementsByClassName
            is live, querySelectorAll is static
          </li>
        </ul>

        <h4>4. Performance Considerations:</h4>
        <div class="code-example">
          // Good: Cache the parent element<br />
          const container = document.getElementById('container');<br />
          for (let i = 0; i < 100; i++) {<br />
          &nbsp;&nbsp;const div = document.createElement('div');<br />
          &nbsp;&nbsp;container.appendChild(div);<br />
          }<br /><br />
          // Better: Use document fragment for bulk operations<br />
          const fragment = document.createDocumentFragment();<br />
          for (let i = 0; i < 100; i++) {<br />
          &nbsp;&nbsp;const div = document.createElement('div');<br />
          &nbsp;&nbsp;fragment.appendChild(div);<br />
          }<br />
          container.appendChild(fragment);
        </div>

        <h4>5. Common Pitfalls to Avoid:</h4>
        <ul>
          <li>
            <strong>Don't modify collections while iterating:</strong> Convert
            to Array first
          </li>
          <li>
            <strong>Check element existence:</strong> Always verify elements
            exist before manipulation
          </li>
          <li>
            <strong>Memory leaks:</strong> Remove event listeners when removing
            elements
          </li>
          <li>
            <strong>Excessive DOM queries:</strong> Cache elements instead of
            repeated queries
          </li>
        </ul>

        <div class="code-example">
          // Dangerous: Modifying live collection while iterating<br />
          const elements = document.getElementsByClassName('item');<br />
          for (let element of elements) {<br />
          &nbsp;&nbsp;element.remove(); // This changes the collection during
          iteration!<br />
          }<br /><br />
          // Safe: Convert to array first<br />
          const elements =
          Array.from(document.getElementsByClassName('item'));<br />
          elements.forEach(element => element.remove());
        </div>
      </div>
    </div>

    <div>
        <div>
            <div>

            </div>
        </div>

        <div>
            
        </div>

    </div>

    <script>
      // Global counter for element creation
      let elementCounter = 0;
      let familyCounter = 0;

      // Section A: Creating and Removing Elements

      /**
       * createElement() - Basic Element Creation
       * Demonstrates the fundamental process of creating DOM elements:
       * 1. Get user input or generate default content
       * 2. Create element using document.createElement()
       * 3. Set properties (className, textContent, etc.)
       * 4. Create and attach event handlers
       * 5. Add element to the DOM tree
       */
      function createElement() {
        const container = document.getElementById("dynamicContainer");
        const text =
          document.getElementById("elementText").value ||
          `Element ${++elementCounter}`;

        // Step 1: Create new element - this exists in memory but not in DOM yet
        const newElement = document.createElement("div");
        newElement.className = "element-item";
        newElement.textContent = text;

       
        // Step 2: Create remove functionality - demonstrates event handling
        const removeBtn = document.createElement("button");
        removeBtn.textContent = "×";
        removeBtn.className = "remove-btn";
        removeBtn.onclick = function () {
          // removeChild requires parent reference - older but widely supported method
          container.removeChild(newElement);
        };

        // Step 3: Build the element structure
        newElement.appendChild(removeBtn);

        // Step 4: Add to DOM - element becomes visible only after this step
        container.appendChild(newElement);

        // Step 5: Clean up UI
        document.getElementById("elementText").value = "";
      }

      /**
       * createElementWithAttributes() - Advanced Element Creation
       * Shows how to work with element attributes and properties:
       * - style properties for dynamic styling
       * - setAttribute() for custom attributes
       * - getAttribute() to read attribute values
       * - title attribute for tooltips
       */
      function createElementWithAttributes() {
        const container = document.getElementById("dynamicContainer");
        const text =
          document.getElementById("elementText").value ||
          `Styled Element ${++elementCounter}`;

        const newElement = document.createElement("div");
        newElement.className = "element-item";

        // Dynamic styling - demonstrates style property manipulation
        newElement.style.backgroundColor = getRandomColor();
        newElement.style.color = "#333";

        // Custom attributes - useful for storing data or metadata
        newElement.setAttribute(
          "data-created",
          new Date().toLocaleTimeString()
        );
        newElement.title = `Created at ${new Date().toLocaleTimeString()}`;

        // innerHTML vs textContent - innerHTML can include HTML tags
        newElement.innerHTML = `
                <strong>${text}</strong>
                <br><small>Created: ${newElement.getAttribute(
                  "data-created"
                )}</small>
            `;

        const removeBtn = document.createElement("button");
        removeBtn.textContent = "×";
        removeBtn.className = "remove-btn";
        removeBtn.onclick = function () {
          container.removeChild(newElement);
        };

        newElement.appendChild(removeBtn);
        container.appendChild(newElement);

        document.getElementById("elementText").value = "";
      }

      /**
       * createWithInnerHTML() - Using innerHTML Method
       * Demonstrates innerHTML for quick HTML content creation
       * Pros: Fast, easy to write complex HTML
       * Cons: Potential XSS vulnerability with user input
       */
      function createWithInnerHTML() {
        const container = document.getElementById("dynamicContainer");
        const div = document.createElement("div");
        div.className = "element-item";

        // innerHTML parses the string as HTML and creates the DOM structure
        div.innerHTML = `
                <h4>Created with innerHTML</h4>
                <p>This element was created using <code>innerHTML</code></p>
                <button onclick="this.parentElement.remove()" class="danger">Remove Me</button>
            `;
        container.appendChild(div);
      }

      /**
       * createWithTextContent() - Using textContent Method
       * Demonstrates safe text-only content creation
       * Pros: XSS-safe, fast for text content
       * Cons: Cannot include HTML formatting
       */
      function createWithTextContent() {
        const container = document.getElementById("dynamicContainer");
        const div = document.createElement("div");
        div.className = "element-item";

        // textContent treats everything as plain text - HTML tags will be displayed as text
        div.textContent = "Created with textContent - Safe from XSS";

        // Must create additional elements separately when using textContent
        const removeBtn = document.createElement("button");
        removeBtn.textContent = "Remove";
        removeBtn.className = "danger";
        removeBtn.onclick = function () {
          container.removeChild(div);
        };

        div.appendChild(removeBtn);
        container.appendChild(div);
      }

      /**
       * createWithAppendChild() - Building Elements Programmatically
       * Demonstrates the most secure and flexible approach to element creation
       * Each element is created separately and assembled step by step
       */
      function createWithAppendChild() {
        const container = document.getElementById("dynamicContainer");
        const div = document.createElement("div");
        div.className = "element-item";

        // Create each element separately for maximum control
        const title = document.createElement("h4");
        title.textContent = "Created with appendChild";

        const paragraph = document.createElement("p");
        paragraph.textContent =
          "Each element was created and appended individually";

        const button = document.createElement("button");
        button.textContent = "Remove";
        button.className = "danger";
        button.onclick = function () {
          container.removeChild(div);
        };

        // Assemble the structure - order matters for layout
        div.appendChild(title);
        div.appendChild(paragraph);
        div.appendChild(button);
        container.appendChild(div);
      }

      /**
       * createComplexElement() - Advanced DOM Structure Building
       * Shows how to create sophisticated nested structures with multiple levels
       * Demonstrates semantic HTML elements (article, header, section, footer)
       */
      function createComplexElement() {
        const container = document.getElementById("dynamicContainer");

        // Use semantic HTML5 elements for better structure
        const article = document.createElement("article");
        article.className = "element-item";
        article.style.border = "2px solid #9c27b0";
        article.style.backgroundColor = "#f3e5f5";

        // Header section with title
        const header = document.createElement("header");
        const title = document.createElement("h3");
        title.textContent = "Complex Element";
        header.appendChild(title);

        // Content section with list
        const content = document.createElement("section");
        const list = document.createElement("ul");

        // Dynamic list creation using array iteration
        ["Feature 1", "Feature 2", "Feature 3"].forEach((feature) => {
          const li = document.createElement("li");
          li.textContent = feature;
          list.appendChild(li);
        });

        content.appendChild(list);

        // Footer with interactive buttons
        const footer = document.createElement("footer");
        const editBtn = document.createElement("button");
        editBtn.textContent = "Edit";
        editBtn.onclick = function () {
          // Demonstrates user interaction and content modification
          title.textContent =
            prompt("Enter new title:", title.textContent) || title.textContent;
        };

        const removeBtn = document.createElement("button");
        removeBtn.textContent = "Remove";
        removeBtn.className = "danger";
        removeBtn.onclick = function () {
          container.removeChild(article);
        };

        footer.appendChild(editBtn);
        footer.appendChild(removeBtn);

        // Assemble the complete structure
        article.appendChild(header);
        article.appendChild(content);
        article.appendChild(footer);
        container.appendChild(article);
      }

      /**
       * clearAllElements() - Bulk Element Removal
       * Demonstrates how to remove multiple elements while preserving specific ones
       * Shows array conversion of HTMLCollection for safe iteration during removal
       */
      function clearAllElements() {
        const container = document.getElementById("dynamicContainer");

        // Convert HTMLCollection to Array to avoid issues when removing elements during iteration
        const children = Array.from(container.children);
        children.forEach((child) => {
          // Preserve the initial instruction paragraph
          if (child.tagName !== "P" || !child.querySelector("em")) {
            container.removeChild(child);
          }
        });
        elementCounter = 0;
      }

      // Section B: Parent-Child Relationships
      function createFamily() {
        const container = document.getElementById("familyTree");
        container.innerHTML = "";

        // Create parent
        const parent = document.createElement("div");
        parent.className = "parent";
        parent.id = "family-parent";
        parent.innerHTML = "<strong>Parent Element</strong>";

        // Create children
        for (let i = 1; i <= 2; i++) {
          const child = document.createElement("div");
          child.className = "child";
          child.innerHTML = `Child ${i}`;
          parent.appendChild(child);
        }

        container.appendChild(parent);
        familyCounter = 2;
      }

      function addChild() {
        const parent = document.getElementById("family-parent");
        if (!parent) {
          alert("Please create a family tree first!");
          return;
        }

        const child = document.createElement("div");
        child.className = "child";
        child.innerHTML = `Child ${++familyCounter}`;
        parent.appendChild(child);
      }

      function addGrandchild() {
        const parent = document.getElementById("family-parent");
        if (!parent) {
          alert("Please create a family tree first!");
          return;
        }

        const children = parent.querySelectorAll(".child");
        if (children.length === 0) {
          alert("No children available to add grandchildren to!");
          return;
        }

        const lastChild = children[children.length - 1];
        const grandchild = document.createElement("div");
        grandchild.className = "grandchild";
        grandchild.innerHTML = `Grandchild of ${lastChild.textContent}`;
        lastChild.appendChild(grandchild);
      }

      function removeLastChild() {
        const parent = document.getElementById("family-parent");
        if (!parent) {
          alert("Please create a family tree first!");
          return;
        }

        const children = parent.querySelectorAll(":scope > .child");
        if (children.length > 0) {
          parent.removeChild(children[children.length - 1]);
          familyCounter--;
        } else {
          alert("No children to remove!");
        }
      }

      function showRelationships() {
        const parent = document.getElementById("family-parent");
        const infoDiv = document.getElementById("relationshipInfo");

        if (!parent) {
          alert("Please create a family tree first!");
          return;
        }

        let info = "<h4>Family Relationships:</h4>";
        info += `<p><strong>Parent:</strong> ${
          parent.querySelector("strong").textContent
        }</p>`;
        info += `<p><strong>Number of children:</strong> ${
          parent.children.length - 1
        }</p>`;
        info += `<p><strong>Total descendants:</strong> ${
          parent.querySelectorAll(".child, .grandchild").length
        }</p>`;

        const children = parent.querySelectorAll(":scope > .child");
        info += "<p><strong>Children:</strong></p><ul>";
        children.forEach((child, index) => {
          const grandchildren = child.querySelectorAll(".grandchild");
          info += `<li>${child.firstChild.textContent} (${grandchildren.length} grandchildren)</li>`;
        });
        info += "</ul>";

        infoDiv.innerHTML = info;
        infoDiv.style.display = "block";
      }

      function insertBefore() {
        const parent = document.getElementById("family-parent");
        if (!parent) {
          alert("Please create a family tree first!");
          return;
        }

        const children = parent.querySelectorAll(":scope > .child");
        if (children.length === 0) {
          alert("No children available!");
          return;
        }

        const newChild = document.createElement("div");
        newChild.className = "child";
        newChild.innerHTML = "Inserted Before First Child";
        newChild.style.backgroundColor = "#ffcdd2";

        parent.insertBefore(newChild, children[0]);
      }

      function insertAfter() {
        const parent = document.getElementById("family-parent");
        if (!parent) {
          alert("Please create a family tree first!");
          return;
        }

        const children = parent.querySelectorAll(":scope > .child");
        if (children.length === 0) {
          alert("No children available!");
          return;
        }

        const newChild = document.createElement("div");
        newChild.className = "child";
        newChild.innerHTML = "Inserted After First Child";
        newChild.style.backgroundColor = "#c8e6c9";

        const firstChild = children[0];
        parent.insertBefore(newChild, firstChild.nextSibling);
      }

      function replaceChild() {
        const parent = document.getElementById("family-parent");
        if (!parent) {
          alert("Please create a family tree first!");
          return;
        }

        const children = parent.querySelectorAll(":scope > .child");
        if (children.length === 0) {
          alert("No children available!");
          return;
        }

        const newChild = document.createElement("div");
        newChild.className = "child";
        newChild.innerHTML = "Replacement Child";
        newChild.style.backgroundColor = "#fff3e0";

        parent.replaceChild(newChild, children[0]);
      }

      function cloneNode() {
        const parent = document.getElementById("family-parent");
        if (!parent) {
          alert("Please create a family tree first!");
          return;
        }

        const children = parent.querySelectorAll(":scope > .child");
        if (children.length === 0) {
          alert("No children available!");
          return;
        }

        // Clone the first child (deep clone to include grandchildren)
        const clonedChild = children[0].cloneNode(true);
        clonedChild.style.backgroundColor = "#e1bee7";
        clonedChild.innerHTML = clonedChild.innerHTML.replace(
          /Child \d+/,
          "Cloned Child"
        );

        parent.appendChild(clonedChild);
      }

      // Section C: DOM Traversal
      function clearHighlights() {
        const highlighted = document.querySelectorAll(".highlighted");
        highlighted.forEach((el) => el.classList.remove("highlighted"));
      }

      function highlightParent() {
        clearHighlights();
        const container = document.getElementById("traversalContainer");
        const firstElement = container.querySelector(".element-item");
        

        if (firstElement && firstElement.parentElement) {
          firstElement.parentElement.classList.add("highlighted");
          showTraversalInfo(
            `Highlighted parent of first element: ${firstElement.parentElement.tagName}`
          );
        }   
      }

      function highlightChildren() {
        clearHighlights();
        const container = document.getElementById("traversalContainer");
        const firstElement = container.querySelector(".element-item");

        if (firstElement) {
          const children = firstElement.children;
          Array.from(children).forEach((child) => {
            child.classList.add("highlighted");
          });
          showTraversalInfo(
            `Highlighted ${children.length} children of first element`
          );
        }
      }

      function highlightSiblings() {
        clearHighlights();
        const container = document.getElementById("traversalContainer");
        const elements = container.querySelectorAll(":scope > .element-item");

        if (elements.length > 1) {
          // Highlight siblings of the first element
          for (let i = 1; i < elements.length; i++) {
            elements[i].classList.add("highlighted");
          }
          showTraversalInfo(
            `Highlighted ${elements.length - 1} siblings of first element`
          );
        }
      }

      function highlightFirstLast() {
        clearHighlights();
        const container = document.getElementById("traversalContainer");
        const elements = container.querySelectorAll(".element-item");

        if (elements.length > 0) {
          elements[0].classList.add("highlighted");
          if (elements.length > 1) {
            elements[elements.length - 1].classList.add("highlighted");
          }
          showTraversalInfo(
            `Highlighted first and last elements (${elements.length} total elements)`
          );
        }
      }

      function queryElements() {
        const selector = document.getElementById("selectorInput").value;
        const resultsDiv = document.getElementById("queryResults");

        if (!selector) {
          alert("Please enter a CSS selector!");
          return;
        }

        try {
          clearHighlights();
          const elements = document.querySelectorAll(selector);

          elements.forEach((el) => el.classList.add("highlighted"));

          let results = `<h4>Query Results for "${selector}":</h4>`;
          results += `<p>Found ${elements.length} elements</p>`;

          if (elements.length > 0) {
            results += "<ul>";
            elements.forEach((el, index) => {
              results += `<li>Element ${index + 1}: ${el.tagName}`;
              if (el.className) results += ` (class: ${el.className})`;
              if (el.id) results += ` (id: ${el.id})`;
              results += "</li>";
            });
            results += "</ul>";
          }

          resultsDiv.innerHTML = results;
          resultsDiv.style.display = "block";
        } catch (error) {
          alert(`Invalid selector: ${error.message}`);
        }
      }

      function demonstrateQueryMethods() {
        const resultsDiv = document.getElementById("queryResults");

        let results = "<h4>Query Method Demonstrations:</h4>";

        // getElementById
        const elementById = document.getElementById("traversalContainer");
        results += `<p><strong>getElementById('traversalContainer'):</strong> ${
          elementById ? "Found" : "Not found"
        }</p>`;

        // getElementsByClassName
        const elementsByClass = document.getElementsByClassName("element-item");
        results += `<p><strong>getElementsByClassName('element-item'):</strong> Found ${elementsByClass.length} elements</p>`;

        // getElementsByTagName
        const elementsByTag = document.getElementsByTagName("div");
        results += `<p><strong>getElementsByTagName('div'):</strong> Found ${elementsByTag.length} elements</p>`;

        // querySelector
        const firstElement = document.querySelector(".element-item");
        results += `<p><strong>querySelector('.element-item'):</strong> ${
          firstElement ? "Found first element" : "Not found"
        }</p>`;

        // querySelectorAll
        const allElements = document.querySelectorAll(".element-item");
        results += `<p><strong>querySelectorAll('.element-item'):</strong> Found ${allElements.length} elements</p>`;

        resultsDiv.innerHTML = results;
        resultsDiv.style.display = "block";
      }

      function walkDOMTree() {
        const resultsDiv = document.getElementById("traversalResults");
        const container = document.getElementById("traversalContainer");

        let treeStructure = "DOM Tree Structure:\n";

        function walkNode(node, depth = 0) {
          const indent = "  ".repeat(depth);
          if (node.nodeType === Node.ELEMENT_NODE) {
            let info = `${indent}${node.tagName}`;
            if (node.id) info += `#${node.id}`;
            if (node.className)
              info += `.${node.className.split(" ").join(".")}`;
            treeStructure += info + "\n";

            // Walk through children
            Array.from(node.children).forEach((child) => {
              walkNode(child, depth + 1);
            });
          }
        }

        walkNode(container);
        resultsDiv.textContent = treeStructure;
        resultsDiv.style.display = "block";
      }

      function findElementsByAttribute() {
        const resultsDiv = document.getElementById("traversalResults");

        // Find elements with data-info attribute
        const elementsWithDataInfo = document.querySelectorAll("[data-info]");

        let results = "Elements with data-info attribute:\n";
        elementsWithDataInfo.forEach((el, index) => {
          results += `${index + 1}. ${
            el.tagName
          } - data-info: "${el.getAttribute("data-info")}"\n`;
          el.classList.add("highlighted");
        });

        resultsDiv.textContent = results;
        resultsDiv.style.display = "block";

        // Clear highlights after 3 seconds
        setTimeout(clearHighlights, 3000);
      }

      function getElementPath() {
        const resultsDiv = document.getElementById("traversalResults");
        const firstElement = document.querySelector(
          "#traversalContainer .element-item"
        );

        if (!firstElement) {
          resultsDiv.textContent = "No element found to trace path";
          resultsDiv.style.display = "block";
          return;
        }

        function getPath(element) {
          const path = [];
          let current = element;

          while (current && current !== document.body) {
            let selector = current.tagName.toLowerCase();

            if (current.id) {
              selector += `#${current.id}`;
            } else if (current.className) {
              selector += `.${current.className.split(" ").join(".")}`;
            }

            // Add position among siblings if needed
            if (!current.id) {
              const siblings = Array.from(current.parentNode.children);
              const index = siblings.indexOf(current);
              if (siblings.length > 1) {
                selector += `:nth-child(${index + 1})`;
              }
            }

            path.unshift(selector);
            current = current.parentElement;
          }

          return path.join(" > ");
        }

        const path = getPath(firstElement);
        firstElement.classList.add("highlighted");

        let results = "Element Path Analysis:\n";
        results += `Full CSS Path: ${path}\n\n`;
        results += "Navigation Properties:\n";
        results += `- parentElement: ${firstElement.parentElement.tagName}\n`;
        results += `- nextElementSibling: ${
          firstElement.nextElementSibling
            ? firstElement.nextElementSibling.tagName
            : "none"
        }\n`;
        results += `- previousElementSibling: ${
          firstElement.previousElementSibling
            ? firstElement.previousElementSibling.tagName
            : "none"
        }\n`;
        results += `- firstElementChild: ${
          firstElement.firstElementChild
            ? firstElement.firstElementChild.tagName
            : "none"
        }\n`;
        results += `- lastElementChild: ${
          firstElement.lastElementChild
            ? firstElement.lastElementChild.tagName
            : "none"
        }\n`;
        results += `- childElementCount: ${firstElement.childElementCount}\n`;

        resultsDiv.textContent = results;
        resultsDiv.style.display = "block";

        // Clear highlight after 3 seconds
        setTimeout(clearHighlights, 3000);
      }

      // Helper Functions
      function getRandomColor() {
        const colors = [
          "#ffebee",
          "#e8f5e8",
          "#e3f2fd",
          "#fff3e0",
          "#f3e5f5",
          "#e0f2f1",
        ];
        return colors[Math.floor(Math.random() * colors.length)];
      }

      function showTraversalInfo(message) {
        const infoDiv = document.getElementById("relationshipInfo");
        infoDiv.innerHTML = `<h4>Traversal Info:</h4><p>${message}</p>`;
        infoDiv.style.display = "block";

        // Auto-hide after 3 seconds
        setTimeout(() => {
          infoDiv.style.display = "none";
        }, 3000);
      }

      // Initialize the page
      document.addEventListener("DOMContentLoaded", function () {
        console.log("DOM Manipulation Demo loaded successfully!");

        // Add some sample content for traversal
        const traversalContainer =
          document.getElementById("traversalContainer");
        const elements = traversalContainer.querySelectorAll(".element-item");

        // Add click handlers for interactive demonstration
        elements.forEach((element, index) => {
          element.addEventListener("click", function () {
            clearHighlights();
            this.classList.add("highlighted");
            showTraversalInfo(
              `Clicked on: ${
                this.getAttribute("data-info") || `Element ${index + 1}`
              }`
            );
          });
        });
      });
    </script>
  </body>
</html>
