<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parent-Child Relationships - Detailed Explanation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            background-color: #f5f5f5;
        }
        
        .container {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        
        h2 {
            color: #27ae60;
            margin-top: 30px;
        }
        
        h3 {
            color: #e74c3c;
            margin-top: 25px;
        }
        
        .code-block {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 15px 0;
            overflow-x: auto;
        }
        
        .highlight {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
        }
        
        .warning {
            background-color: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 15px;
            margin: 15px 0;
        }
        
        .info {
            background-color: #d1ecf1;
            border-left: 4px solid #17a2b8;
            padding: 15px;
            margin: 15px 0;
        }
        
        .tree-visual {
            font-family: monospace;
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #dee2e6;
            margin: 20px 0;
        }
        
        .relationship-table {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .parent-demo {
            background-color: #d4edda;
            border: 2px solid #28a745;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .child-demo {
            background-color: #d1ecf1;
            border: 2px solid #17a2b8;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0 5px 20px;
        }
        
        .grandchild-demo {
            background-color: #fff3cd;
            border: 2px solid #ffc107;
            padding: 8px;
            border-radius: 5px;
            margin: 3px 0 3px 40px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        table, th, td {
            border: 1px solid #ddd;
        }
        
        th, td {
            padding: 12px;
            text-align: left;
        }
        
        th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
        
        .method-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }
        
        .method-card {
            border: 1px solid #dee2e6;
            padding: 15px;
            border-radius: 5px;
            background-color: #f8f9fa;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Parent-Child Relationships in the DOM</h1>
        
        <div class="info">
            <strong>Learning Objectives:</strong>
            <ul>
                <li>Understand DOM hierarchy and tree structure</li>
                <li>Master parent-child relationship navigation</li>
                <li>Learn insertion and positioning methods</li>
                <li>Handle complex nested structures</li>
            </ul>
        </div>

        <h2>1. Understanding DOM Hierarchy</h2>
        
        <p>The DOM (Document Object Model) represents HTML as a tree structure where every element can have:</p>
        <ul>
            <li><strong>One Parent:</strong> The element that contains it (except the root)</li>
            <li><strong>Multiple Children:</strong> Elements nested inside it</li>
            <li><strong>Siblings:</strong> Elements at the same level with the same parent</li>
        </ul>

        <div class="tree-visual">
Document
├── html
    ├── head
    │   ├── title
    │   └── meta
    └── body
        ├── header
        │   ├── h1
        │   └── nav
        │       ├── ul
        │           ├── li
        │           ├── li
        │           └── li
        ├── main
        │   ├── section
        │   └── article
        └── footer
        </div>

        <h2>2. Key Relationship Properties</h2>

        <table>
            <thead>
                <tr>
                    <th>Property</th>
                    <th>Returns</th>
                    <th>Description</th>
                    <th>Example</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>parentElement</code></td>
                    <td>Element or null</td>
                    <td>Direct parent element</td>
                    <td><code>child.parentElement</code></td>
                </tr>
                <tr>
                    <td><code>children</code></td>
                    <td>HTMLCollection</td>
                    <td>All child elements</td>
                    <td><code>parent.children</code></td>
                </tr>
                <tr>
                    <td><code>firstElementChild</code></td>
                    <td>Element or null</td>
                    <td>First child element</td>
                    <td><code>parent.firstElementChild</code></td>
                </tr>
                <tr>
                    <td><code>lastElementChild</code></td>
                    <td>Element or null</td>
                    <td>Last child element</td>
                    <td><code>parent.lastElementChild</code></td>
                </tr>
                <tr>
                    <td><code>nextElementSibling</code></td>
                    <td>Element or null</td>
                    <td>Next sibling element</td>
                    <td><code>element.nextElementSibling</code></td>
                </tr>
                <tr>
                    <td><code>previousElementSibling</code></td>
                    <td>Element or null</td>
                    <td>Previous sibling element</td>
                    <td><code>element.previousElementSibling</code></td>
                </tr>
            </tbody>
        </table>

        <h3>Practical Example: Navigating Relationships</h3>
        <div class="code-block">
// HTML Structure:
// &lt;div id="container"&gt;
//   &lt;p&gt;First paragraph&lt;/p&gt;
//   &lt;p id="middle"&gt;Middle paragraph&lt;/p&gt;
//   &lt;p&gt;Last paragraph&lt;/p&gt;
// &lt;/div&gt;

const middle = document.getElementById('middle');

// Parent relationship
console.log(middle.parentElement.id); // "container"

// Sibling relationships
console.log(middle.previousElementSibling.textContent); // "First paragraph"
console.log(middle.nextElementSibling.textContent); // "Last paragraph"

// Children from parent
const container = middle.parentElement;
console.log(container.children.length); // 3
console.log(container.firstElementChild.textContent); // "First paragraph"
console.log(container.lastElementChild.textContent); // "Last paragraph"
        </div>

        <h2>3. Creating Parent-Child Structures</h2>

        <h3>Basic Structure Creation</h3>
        <div class="code-block">
// Create a card component with nested structure
function createUserCard(user) {
    // Parent container
    const card = document.createElement('div');
    card.className = 'user-card';
    
    // Child: Header
    const header = document.createElement('header');
    
    // Grandchild: Avatar
    const avatar = document.createElement('img');
    avatar.src = user.avatar;
    avatar.alt = user.name;
    
    // Grandchild: Name
    const name = document.createElement('h3');
    name.textContent = user.name;
    
    // Build header structure
    header.appendChild(avatar);
    header.appendChild(name);
    
    // Child: Content
    const content = document.createElement('div');
    content.className = 'user-info';
    
    // Grandchildren: Info items
    const email = document.createElement('p');
    email.textContent = user.email;
    
    const role = document.createElement('p');
    role.textContent = user.role;
    
    // Build content structure
    content.appendChild(email);
    content.appendChild(role);
    
    // Assemble final structure
    card.appendChild(header);
    card.appendChild(content);
    
    return card;
}
        </div>

        <h2>4. Element Insertion Methods</h2>

        <div class="method-comparison">
            <div class="method-card">
                <h4>appendChild()</h4>
                <div class="code-block">
parent.appendChild(child);
                </div>
                <p><strong>Purpose:</strong> Add as last child</p>
                <p><strong>Returns:</strong> The appended child</p>
            </div>
            
            <div class="method-card">
                <h4>insertBefore()</h4>
                <div class="code-block">
parent.insertBefore(newChild, referenceChild);
                </div>
                <p><strong>Purpose:</strong> Insert before specific child</p>
                <p><strong>Returns:</strong> The inserted child</p>
            </div>
            
            <div class="method-card">
                <h4>replaceChild()</h4>
                <div class="code-block">
parent.replaceChild(newChild, oldChild);
                </div>
                <p><strong>Purpose:</strong> Replace existing child</p>
                <p><strong>Returns:</strong> The replaced child</p>
            </div>
        </div>

        <h3>Advanced Insertion Techniques</h3>

        <h4>Insert After (Custom Implementation)</h4>
        <div class="code-block">
function insertAfter(newElement, referenceElement) {
    const parent = referenceElement.parentElement;
    const nextSibling = referenceElement.nextElementSibling;
    
    if (nextSibling) {
        // Insert before the next sibling
        parent.insertBefore(newElement, nextSibling);
    } else {
        // Reference element is the last child, append normally
        parent.appendChild(newElement);
    }
}

// Usage
const newItem = document.createElement('li');
newItem.textContent = 'New item';
insertAfter(newItem, document.getElementById('second-item'));
        </div>

        <h4>Insert at Specific Position</h4>
        <div class="code-block">
function insertAtPosition(parent, newElement, position) {
    const children = parent.children;
    
    if (position >= children.length) {
        // Position is beyond the end, append normally
        parent.appendChild(newElement);
    } else if (position <= 0) {
        // Insert at the beginning
        parent.insertBefore(newElement, children[0]);
    } else {
        // Insert at specific position
        parent.insertBefore(newElement, children[position]);
    }
}

// Usage
const list = document.getElementById('myList');
const newItem = document.createElement('li');
insertAtPosition(list, newItem, 2); // Insert as 3rd item (0-indexed)
        </div>

        <h2>5. Element Cloning</h2>

        <div class="highlight">
            <strong>cloneNode():</strong> Creates a copy of an element with optional deep cloning of children.
        </div>

        <div class="code-block">
// Shallow clone (element only, no children)
const shallowClone = element.cloneNode(false);

// Deep clone (element and all descendants)
const deepClone = element.cloneNode(true);

// Practical example: Cloning a template
const template = document.getElementById('userTemplate');
const userClone = template.cloneNode(true);

// Modify the clone
userClone.id = 'user-' + userId;
userClone.querySelector('.name').textContent = userName;
userClone.querySelector('.email').textContent = userEmail;

// Add to DOM
document.getElementById('userContainer').appendChild(userClone);
        </div>

        <div class="warning">
            <strong>Important:</strong> When cloning elements:
            <ul>
                <li>Event listeners are NOT copied</li>
                <li>IDs should be changed to maintain uniqueness</li>
                <li>Form values are preserved in the clone</li>
            </ul>
        </div>

        <h2>6. Working with HTMLCollections vs NodeLists</h2>

        <table>
            <thead>
                <tr>
                    <th>Collection Type</th>
                    <th>Live/Static</th>
                    <th>Methods</th>
                    <th>Example</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>HTMLCollection (children)</td>
                    <td>Live</td>
                    <td>length, item(), namedItem()</td>
                    <td><code>element.children</code></td>
                </tr>
                <tr>
                    <td>NodeList (querySelectorAll)</td>
                    <td>Static</td>
                    <td>length, item(), forEach()</td>
                    <td><code>document.querySelectorAll()</code></td>
                </tr>
                <tr>
                    <td>NodeList (childNodes)</td>
                    <td>Live</td>
                    <td>length, item()</td>
                    <td><code>element.childNodes</code></td>
                </tr>
            </tbody>
        </table>

        <h3>Safe Iteration During Modification</h3>
        <div class="code-block">
// DANGEROUS: Modifying live collection while iterating
const children = parent.children;
for (let i = 0; i < children.length; i++) {
    parent.removeChild(children[i]); // This skips elements!
}

// SAFE: Convert to array first
const childrenArray = Array.from(parent.children);
childrenArray.forEach(child => {
    parent.removeChild(child);
});

// SAFE: Iterate backwards
for (let i = parent.children.length - 1; i >= 0; i--) {
    parent.removeChild(parent.children[i]);
}

// MODERN: Use remove() on elements
Array.from(parent.children).forEach(child => child.remove());
        </div>

        <h2>7. Practical Examples and Patterns</h2>

        <h3>Building a Dynamic Menu</h3>
        <div class="code-block">
function createMenu(menuData) {
    const nav = document.createElement('nav');
    nav.className = 'main-menu';
    
    const ul = document.createElement('ul');
    
    menuData.forEach(item => {
        const li = document.createElement('li');
        
        if (item.children) {
            // Create submenu
            li.className = 'has-submenu';
            
            const link = document.createElement('a');
            link.href = item.url;
            link.textContent = item.title;
            
            const submenu = document.createElement('ul');
            submenu.className = 'submenu';
            
            item.children.forEach(subItem => {
                const subLi = document.createElement('li');
                const subLink = document.createElement('a');
                subLink.href = subItem.url;
                subLink.textContent = subItem.title;
                
                subLi.appendChild(subLink);
                submenu.appendChild(subLi);
            });
            
            li.appendChild(link);
            li.appendChild(submenu);
        } else {
            // Simple menu item
            const link = document.createElement('a');
            link.href = item.url;
            link.textContent = item.title;
            li.appendChild(link);
        }
        
        ul.appendChild(li);
    });
    
    nav.appendChild(ul);
    return nav;
}
        </div>

        <h3>Form Builder with Nested Elements</h3>
        <div class="code-block">
function createFormField(config) {
    const fieldContainer = document.createElement('div');
    fieldContainer.className = 'form-field';
    
    // Label
    const label = document.createElement('label');
    label.textContent = config.label;
    label.setAttribute('for', config.id);
    
    // Input element
    let input;
    switch (config.type) {
        case 'textarea':
            input = document.createElement('textarea');
            break;
        case 'select':
            input = document.createElement('select');
            config.options.forEach(option => {
                const optionEl = document.createElement('option');
                optionEl.value = option.value;
                optionEl.textContent = option.text;
                input.appendChild(optionEl);
            });
            break;
        default:
            input = document.createElement('input');
            input.type = config.type;
            break;
    }
    
    input.id = config.id;
    input.name = config.name;
    
    if (config.required) {
        input.required = true;
    }
    
    // Validation message container
    const errorMsg = document.createElement('div');
    errorMsg.className = 'error-message';
    errorMsg.style.display = 'none';
    
    // Assemble field
    fieldContainer.appendChild(label);
    fieldContainer.appendChild(input);
    fieldContainer.appendChild(errorMsg);
    
    return fieldContainer;
}
        </div>

        <h2>8. Performance Considerations</h2>

        <div class="highlight">
            <h3>DocumentFragment for Bulk Operations</h3>
            <p>When adding multiple elements, use DocumentFragment to minimize DOM reflows:</p>
        </div>

        <div class="code-block">
function addMultipleItems(container, items) {
    // Create fragment (exists in memory, not DOM)
    const fragment = document.createDocumentFragment();
    
    items.forEach(item => {
        const li = document.createElement('li');
        li.textContent = item.text;
        li.setAttribute('data-id', item.id);
        fragment.appendChild(li); // No DOM reflow yet
    });
    
    // Single DOM operation
    container.appendChild(fragment);
}

// Usage
const itemList = document.getElementById('itemList');
const items = [
    { id: 1, text: 'Item 1' },
    { id: 2, text: 'Item 2' },
    { id: 3, text: 'Item 3' }
];
addMultipleItems(itemList, items);
        </div>

        <h2>9. Common Pitfalls and Solutions</h2>

        <div class="warning">
            <h3>Pitfall 1: Modifying Live Collections</h3>
            <div class="code-block">
// WRONG: This will skip elements
const items = container.children;
for (let i = 0; i < items.length; i++) {
    if (items[i].classList.contains('remove')) {
        container.removeChild(items[i]);
    }
}

// RIGHT: Convert to static array first
const items = Array.from(container.children);
items.forEach(item => {
    if (item.classList.contains('remove')) {
        container.removeChild(item);
    }
});
            </div>
        </div>

        <div class="warning">
            <h3>Pitfall 2: Memory Leaks with Event Listeners</h3>
            <div class="code-block">
// WRONG: Event listeners remain after removal
function createButton() {
    const button = document.createElement('button');
    button.addEventListener('click', heavyEventHandler);
    return button;
}

// RIGHT: Clean up event listeners
function removeElementSafely(element) {
    // Remove event listeners
    element.removeEventListener('click', heavyEventHandler);
    
    // Then remove from DOM
    element.remove();
}
            </div>
        </div>

        <h2>10. Best Practices Summary</h2>

        <div class="info">
            <ul>
                <li><strong>Plan your structure:</strong> Design the hierarchy before coding</li>
                <li><strong>Use semantic HTML:</strong> Choose appropriate element types</li>
                <li><strong>Cache parent references:</strong> Avoid repeated DOM queries</li>
                <li><strong>Handle edge cases:</strong> Check for null parents/children</li>
                <li><strong>Clean up properly:</strong> Remove event listeners when removing elements</li>
                <li><strong>Use DocumentFragment:</strong> For bulk operations</li>
                <li><strong>Prefer modern methods:</strong> Use remove() over removeChild() when possible</li>
                <li><strong>Validate inputs:</strong> Check element existence before manipulation</li>
            </ul>
        </div>

        <h2>11. Practice Exercises</h2>

        <div class="info">
            <h3>Exercise 1: Family Tree Builder</h3>
            <p>Create a function that builds a family tree from nested data, showing relationships visually.</p>
        </div>

        <div class="info">
            <h3>Exercise 2: Sortable List</h3>
            <p>Build a list where items can be moved up/down using parent-child manipulation.</p>
        </div>

        <div class="info">
            <h3>Exercise 3: Nested Comment System</h3>
            <p>Create a comment system with replies and nested sub-replies.</p>
        </div>
    </div>
</body>
</html>
